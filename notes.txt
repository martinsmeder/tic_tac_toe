-----------------------------------> RULE OF THUMB <----------------------------------

* If you only need one of something (gameBoard, displayController, etc), use a module[pattern]

* If you need multiples of something (like players), create them with factories


-------------------------------> FACTORY FUNCTION BASICS <-----------------------------

// Define factory function
const personFactory = (name, age) => {
  // Create sayHello function
  const sayHello = () => console.log("hello"); 
  // Return an object with name, age and sayHello properties
  return { name, age, sayHello };
};

// Create a new object by invoking the factory function
const jeff = personFactory("jeff", 27);

console.log(jeff.name); // 'jeff'

jeff.sayHello(); // Calls the function and logs 'hello'

console.log(jeff); // Logs the jeff object to the console

==========================================

const name = "Maynard";
const color = "red";
const number = 34;
const food = "rice";

console.log(name, color, number, food);
// Logging variables as they are...
// Maynard red 34 rice

console.log({ name, color, number, food });
// Turn into object...
// { name: 'Maynard', color: 'red', number: 34, food: 'rice' }


----------------------------> MORE FACTORY FUNCTIONS <--------------------------------

// Factories are just regular js functions that return objects to use in our code

// Define a factory function Player that returns an object with several properties
const Player = (name, level) => {
  // Initialize the health variable based on level
  let health = level * 2;

  // Define methods that returns parameters
  const getLevel = () => level;
  const getName = () => name;

  // Define a method die that is not implemented but would be called 
  // when a player's health reaches 0
  const die = () => {
    // uh oh
  };

  // Define a method damage that subtracts the amount of damage taken from the 
  // player's health and calls the die method if health reaches 0
  const damage = (x) => {
    health -= x;
    if (health <= 0) {
      die();
    }
  };

  // Define a method attack that takes an enemy as a parameter, compares levels, and 
  // damages the appropriate player accordingly
  const attack = (enemy) => {
    if (level < enemy.getLevel()) {
      damage(1);
      console.log(`${enemy.getName()} has damaged ${name}`);
    }
    if (level >= enemy.getLevel()) {
      enemy.damage(1);
      console.log(`${name} has damaged ${enemy.getName()}`);
    }
  };

  // Return an object with several properties: attack, damage, getLevel, and getName
  return { attack, damage, getLevel, getName };
};

// Create two instances of the Player object: jimmie and badGuy
const jimmie = Player("jim", 10);
const badGuy = Player("jeff", 5);

// Call the attack method on jimmie with badGuy as a parameter
jimmie.attack(badGuy); // jim has damaged jeff
 
============================ INHERITANCE WITH FACTORIES

 // Define a factory function Person that returns an object with one method: sayName
const Person = (name) => {
  // Define a method sayName that logs a string with the person's name
  const sayName = () => console.log(`my name is ${name}`);

  // Return an object with one property: sayName
  return { sayName };
};

// Define a factory function Nerd that returns an object with two methods: sayName 
// and doSomethingNerdy
const Nerd = (name) => {
  // Create a new object prototype that inherits the sayName method from Person
  const prototype = Person(name);

  // Define a method doSomethingNerdy that logs a string
  const doSomethingNerdy = () => console.log("nerd stuff");

  // Return an object that has all properties from the prototype object (sayName), 
  // as well as the doSomethingNerdy property
  return Object.assign({}, prototype, { doSomethingNerdy });
};

// Create a new instance of the Nerd object named jeff
const jeff = Nerd("jeff");

// Call the sayName method on the jeff object
jeff.sayName(); // my name is jeff

// Call the doSomethingNerdy method on the jeff object
jeff.doSomethingNerdy(); // nerd stuff


-------------------------------> SCOPE AND CLOSURE <-----------------------------------

// The concept of closure is the idea that functions can keep their scope even if they
// are passed around and called outside of that scope. In this case, printString has
// access to everything inside of FactoryFunction, even if it gets called outside of
// that function. The reason that only taco.printString() works and not printString()
// is that taco.printString() has access to the printString() function through the
// taco object returned by FactoryFunction. Calling printString() directly won't work
// since printString() is not defined in the global scope and cannot be accessed 
// outside of the FactoryFunction.

const FactoryFunction = (string) => {
  const capitalizeString = () => string.toUpperCase();
  const printString = () => console.log(`-----${capitalizeString()}-----`);
  return { printString };
};

const taco = FactoryFunction("taco");

// printString(); // ERROR!!
// capitalizeString(); // ERROR!!
// taco.capitalizeString(); // ERROR!!
taco.printString(); // prints "-----TACO-----" in console

===========================================

// Closures allow 
// us to create private variables and functions. This results in cleaner and easier
// to read code. The code will also be easier to refactor, easier to test and easier to
// reason about for you or anyone who wants to use your objects. Use as often as 
// possible.

const counterCreator = () => {
  let count = 0;
  return () => {
    console.log(count);
    count++;
  };
};

// Assign function to variable in order to use it (this is a closure).
const counter = counterCreator();

counter(); // 0
counter(); // 1
counter(); // 2
counter(); // 3

------------------------------> THE MODULE PATTERN <----------------------------------

The concepts are exactly the same as the factory function. However, instead of 
creating a factory that we can use over and over again to create multiple objects, 
the module pattern wraps the factory in an IIFE (Immediately Invoked Function 
Expression).


// create an immediately invoked function expression (IIFE) that defines calculator
// object
const calculator = (() => {
  // define private functions inside IIFE
  const add = (a, b) => a + b;
  const sub = (a, b) => a - b;
  const mul = (a, b) => a * b;
  const div = (a, b) => a / b;
  // return calculator object with properties that reference the private functions
  return {
    add,
    sub,
    mul,
    div,
  };
})();

// call the methods of the calculator object and log the results to the console
console.log(calculator.add(3, 5)); // 8
console.log(calculator.sub(6, 2)); // 4
console.log(calculator.mul(14, 5534)); // 77476

============================================

// create a mock implementation of document.querySelector
const documentMock = (() => ({
  querySelector: (selector) => ({
    innerHTML: null,
  }),
}))();

// create Formatter module
const Formatter = (function (doc) {
  // private method to log a message
  const log = (message) => console.log(`[${Date.now()}] Logger: ${message}`);

  // public method to convert text to uppercase
  const makeUppercase = (text) => {
    log("Making uppercase");
    return text.toUpperCase();
  };

  // public method to write message to the DOM
  const writeToDOM = (selector, message) => {
    doc.querySelector(selector).innerHTML = message;
  };

  // expose public methods
  return {
    makeUppercase,
    writeToDOM,
  };
})(document || documentMock); // use the real document if available, otherwise use mock


-------------------------------------> Q & A <-----------------------------------------

Common bugs with constructors: 
Constructors may not be called with the 'new' keyword or may be called with incorrect 
parameters or may not initialize the object's properties correctly.

JavaScript scope: 
Scope determines the visibility and accessibility of variables and functions in 
different parts of code. ES6 introduced 'let' and 'const' keywords to declare 
block-scoped variables, replacing 'var' which is function-scoped.

Closure: 
Closure is a feature in JavaScript that allows inner functions to access variables 
from their outer (enclosing) functions even after the outer function has completed 
execution. This can be used to create private functions and variables.

Private functions & variables: 
Private functions and variables can only be accessed within the same scope or closure 
in which they are declared. They help prevent naming conflicts and accidental 
modification of important variables.

Module pattern: 
The module pattern is a design pattern in JavaScript that allows for encapsulation of 
functionality and data within a single object. This helps to avoid naming conflicts 
and provides a way to organize code.

IIFE: 
IIFE stands for Immediately Invoked Function Expression. It is a way to create a 
self-contained scope for a block of code that runs immediately when the code is loaded. 
This can be used to avoid naming conflicts and to prevent variables from leaking into 
the global scope.

Namespacing: 
Namespacing is a technique used in programming to avoid naming conflicts between 
different parts of code. It involves encapsulating related functionality and data 
within a unique namespace or object. This helps to organize code and avoid naming 
conflicts.